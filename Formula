using System;
using System.Collections.Generic;

namespace Kursovaya
{
    public static class Formulas
    {
        public static double Srednee(int column, List<List<double>> array)
        {
            double sum = 0;
            int row = 0;
            for (; row < array.Count - 2; row++)
            {
                sum += Math.Abs(array[0][column] - array[row][column]);
            }
            return Math.Round(sum / row, 4);
        }

        public static double MU(int rowIndex, List<List<double>> array)
        {
            double sum = 0;
            for (int column = 1; column < array[rowIndex].Count; column++)
            {
                sum += Math.Pow(array[rowIndex][column], 2);
            }
            return Math.Sqrt(sum);
        }

        public static double Alpha(int rowIndex, List<List<double>> primalArray, List<List<double>> newArray)
        {
            double numerator = 0;
            double divider;

            for (int column = 1; column < primalArray[rowIndex].Count; column++)
                numerator += primalArray[0][column] * primalArray[rowIndex][column];

            divider = newArray[0][1] * newArray[rowIndex][1];

            if (numerator / divider > 1)
                numerator = divider;
            if ((numerator / divider) > 1 - 1e-12 && (numerator / divider) != 1)
                return 0;
            return (180 / Math.PI) * Math.Acos(numerator / divider);
        }

        public static double GetFirstPrediction(int column, List<List<double>> array)
        {
            double sum = 0;
            int i = 0;
            for (; i < array.Count; i++)
            {
                sum += array[i][column];
            }
            return Form1.CF * array[0][column] + (1 - Form1.CF) * (sum / i);
        }

        public static double GetPrediction(int rowIndex, int primalColumn, int predictionColumn, List<List<double>> array)
        {
            return Form1.CF * array[rowIndex][primalColumn] + (1 - Form1.CF) * array[rowIndex - 1][predictionColumn];
        }

        public static double GetLastPrediction(int primalColumn, int predictionColumn, List<List<double>> array)
        {
            double sum = 0;
            int i = 0;
            for (; i < array.Count - 1; i++)
            {
                sum += array[i][primalColumn];
            }
            return Form1.CF * (sum / i) + (1 - Form1.CF) * array[i - 1][predictionColumn];
        }

        public static double LeftMU(int rowIndex, List<List<double>> array)
        {
            double sum = 0;
            for (int column = 1; column < array[rowIndex].Count; column++)
            {
                sum += Math.Pow(array[rowIndex][column] - Form1.tochnost, 2);
            }
            return Math.Sqrt(sum);
        }

        public static double RightMU(int rowIndex, List<List<double>> array)
        {
            double sum = 0;
            for (int column = 1; column < array[rowIndex].Count; column++)
            {
                sum += Math.Pow(array[rowIndex][column] + Form1.tochnost, 2);
            }
            return Math.Sqrt(sum);
        }

        public static double LeftAlpha(int rowIndex, List<List<double>> primalArray, List<List<double>> newArray)
        {
            double numerator = 0;
            double divider;

            for (int column = 1; column < primalArray[rowIndex].Count; column++)
                numerator += (primalArray[0][column] - Form1.tochnost) * (primalArray[rowIndex][column] - Form1.tochnost);

            divider = newArray[0][5] * newArray[rowIndex][5];

            if (numerator / divider > 1)
                numerator = divider;
            if ((numerator / divider) > 1 - 1e-12 && (numerator / divider) != 1)
                return 0;
            return (180 / Math.PI) * Math.Acos(numerator / divider);
        }

        public static double RightAlpha(int rowIndex, List<List<double>> primalArray, List<List<double>> newArray)
        {
            double numerator = 0;
            double divider;

            for (int column = 1; column < primalArray[rowIndex].Count; column++)
                numerator += (primalArray[0][column] + Form1.tochnost) * (primalArray[rowIndex][column] + Form1.tochnost);

            divider = newArray[0][6] * newArray[rowIndex][6];

            if (numerator / divider > 1)
                numerator = divider;
            if ((numerator / divider) > 1 - 1e-12 && (numerator / divider) != 1)
                return 0;
            return (180 / Math.PI) * Math.Acos(numerator / divider);
        }

        public static string CheckStability(int row, List<List<double>> newArray)
        {
            if (newArray[row][9] >= newArray[row][10])
                return "устойчиво";
            else return "неустойчиво";
        }
    }
}
